---
title: "Untitled"
author: "Aaila"
date: '2019-02-14'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:
#install packages
```{r}
#install.packages("ggplot2")
library(ggplot2)

#install.packages("tidyr")
library(tidyr)

#install.packages("purrr")
library(purrr)

#install.packages("corrplot")
library(corrplot)

#install.packages("DMwR")
library(DMwR)

#install.packages("rpart")
library(rpart)

#install.packages("randomForest")
library(randomForest)
```

# read data into a dataframe and view structure
```{r cars}
#data1 <- read.csv(file.choose(), header = TRUE)
#str(data1)

housing <- read.csv("housing.csv", header=TRUE, sep=",")

View(housing)
nrow(housing)
ncol(housing)
str(housing)
sum(is.na(housing))

housing_numeric <- housing[,0:9]
#head(housing_numeric)

#print range of each column
#for (i in 1:ncol(housing_numeric)){
#  r<-range(housing_numeric[i])
#  print(r)
#}
summary(housing)

table(housing$ocean_proximity)

```
#fixing  missing values using KNN imputation
```{r}
#row index for total_bedrooms having missing values
na.index <- which(is.na(housing$total_bedrooms))
na.index

housing_KnnImpute <- knnImputation(housing, k = 5)
#confirm if all missing values have been replaced
sum(is.na(housing_KnnImpute))
#housing_KnnImpute[!complete.cases(housing_KnnImpute),]

#converts the number of bedrooms calculated from real to integer 
housing_KnnImpute$total_bedrooms <- as.integer(housing_KnnImpute$total_bedrooms)

#print rows where the missing values have been replaced
housing_KnnImpute[na.index,]

#boxplot(housing_KnnImpute[,names(housing_KnnImpute) != 'median_house_value'])
#boxplot(housing_KnnImpute$total_rooms)
#?knn.impute
#?impute.knn
```

# fix total_rooms, total_bedrooms and population columns to represent per house averages
```{r}
#rooms per household
housing_KnnImpute$mean_rooms <- housing_KnnImpute$total_rooms / housing_KnnImpute$households
#bedrooms per household
housing_KnnImpute$mean_bedrooms <- housing_KnnImpute$total_bedrooms/housing_KnnImpute$total_rooms
#
housing_KnnImpute$people_per_household <- housing_KnnImpute$population/housing_KnnImpute$households
names(housing_KnnImpute)

housing_KnnImpute <- subset(housing_KnnImpute, select = (-c(total_rooms,total_bedrooms,population)))

```
#change categorical column "ocean_proximity" to factor
```{r}
is.factor(housing_KnnImpute$ocean_proximity)
housing_KnnImpute$ocean_proximity <- as.numeric(housing_KnnImpute$ocean_proximity)
# levels = <1H OCEAN     INLAND     ISLAND   NEAR BAY NEAR OCEAN 
# labels =      1           2         3       4           5
table(housing_KnnImpute$ocean_proximity)
table(housing$ocean_proximity)
```
#normalize data
```{r}
names(housing_KnnImpute)
h1 <- as.data.frame(scale(housing_KnnImpute[1:5]))
h2 <- as.data.frame(scale(housing_KnnImpute[8:10]))
h3 <- as.data.frame(housing_KnnImpute[7:6])
housing_clean <- cbind(h1,h2,h3)
class(housing_clean)
head(housing_clean)
```

# create histograms of numeric variables to see distribution
```{r}
housing_clean %>%
  keep(is.numeric) %>% 
  gather() %>% 
  ggplot(aes(value)) +
    facet_wrap(~ key, scales = "free") +
    geom_histogram()

housing_KnnImpute %>%
  keep(is.numeric) %>% 
  gather() %>% 
  ggplot(aes(value)) +
    facet_wrap(~ key, scales = "free") +
    geom_histogram()

housing %>%
  keep(is.numeric) %>% 
  gather() %>% 
  ggplot(aes(value)) +
    facet_wrap(~ key, scales = "free") +
    geom_histogram()

str(housing_KnnImpute$mean_bedrooms)
#hist(housing_KnnImpute$mean_rooms, breaks = 6)

pairs(housing_KnnImpute[-10])
#for (col in 1:ncol(housing)) {
#    hist(housing[,col])
#}
```

#plot latitude longitude
```{r}
plot(housing$longitude, housing$latitude, type = "p", col = "dark red")
```
#view correlations
```{r}
#plot of normalized data
housing_clean %>% keep(is.numeric)  %>% cor() %>% round(2) %>% corrplot(method="circle")
#housing[!complete.cases(housing),]
#complete.cases to filter out rows containing NA's

housing_KnnImpute[complete.cases(housing_KnnImpute),] %>% keep(is.numeric)  %>% cor() %>% round(2) %>% corrplot(method="circle")
?dummyVars

```
#Boxplots to see outliers
```{r}
boxplot(housing[-9])
boxplot(housing_clean[-10])
boxplot.stats(housing_KnnImpute$mean_rooms)

housing.oceanprox.tab <- table(housing$ocean_proximity)
housing.oceanprox.tab

housing.totalrooms.tab <- table(housing$total_rooms)
housing.totalrooms.tab

```

#create train and test sets
```{r}
train_index <- sample(1:nrow(housing_clean), 0.7 * nrow(housing_clean))
housing_train <- housing_clean[train_index,]
housing_test  <- housing_clean[-train_index,]
head(housing_train)
#nrow(train.set)+nrow(test.set)
```

#create linear regression model
```{r}
#linear model
glm_model <- glm(housing_train$median_house_value ~., data = housing_train)
glm_model$coefficients
summary(glm_model)

#predict prices for test data
predicted_price <- predict(glm_model, housing_test[-10], type="response")
predicted_price <- as.integer(trunc(predicted_price))
head(predicted_price)

#plot predicted and actual prices
plot(housing_test$median_house_value,  col = "green", ylim = c(10000,500000), ylab = "Median House Prices")
par(new=TRUE)
#lines(predicted_price, col="red")
plot(predicted_price, type = "o", col = "red", ylim = c(10000,500000), ylab = "Median House Prices")
range(predicted_price)
#confusionMatrix <- table(actual = housing_test$median_house_value, predicted = predicted_price)
#confusionMatrix # This is the confusion matrix
#sum(diag(confusionMatrix))/nrow(housing_test) # This is the accuracy

glm_model1 <- glm(median_house_value~ households + median_income + mean_rooms + people_per_household, data = housing_clean)
glm_model1$coefficients
summary(glm_model1)

predicted_price1 <- predict(glm_model1, housing_test, type="response")
predicted_price1 <- as.integer(trunc(predicted_price1))
head(predicted_price)

plot(housing_test$median_house_value,  col = "green")
par(new=TRUE)
#lines(predicted_price, col="red")
plot(predicted_price1, type = "l", col = "red")
range(predicted_price)

```

#decision tree regression
```{r}
fit <- rpart(median_house_value ~., method = "anova", data = housing_train)
printcp(fit)  # display the results 
plotcp(fit)   # visualize cross-validation results 
summary(fit)  # detailed summary of splits

# create additional plots 
par(mfrow=c(1,2)) # two plots on one page 
rsq.rpart(fit) # visualize cross-validation results   

# plot tree 
plot(fit, uniform=TRUE, 
   main="Regression Tree for House Price Prediction")
text(fit, use.n=TRUE, all=TRUE, cex=.8)

#prune the tree
pfit<- prune(fit, cp=0.012359) # from cptable   

# plot the pruned tree 
plot(pfit, uniform=TRUE, 
   main="Pruned Regression Tree for House Price Prediction")
text(pfit, use.n=TRUE, all=TRUE, cex=.8)

#predicting accuracy
RT_pred <- predict(fit, housing_test)
RT_pred <- as.integer(trunc(RT_pred))
head(RT_pred)
sum(RT_pred == housing_test[,10])

df <- data.frame(predicted=RT_pred, actual = housing_test[,10])
head(df)
df$percent_error <- ((df$predicted-df$actual)/df$actual) *100
mean(df$percent_error)
```

# Random Forest
```{r}
RF_fit <- randomForest(median_house_value ~ . ,   data=housing_train, importance = TRUE)

print(RF_fit) # view results 
importance(RF_fit) # importance of each predictor

plot(RF_fit)  #Plotting the Error vs Number of Trees Graph
names(RF_fit)

pred<-predict(RF_fit,housing_test) #Predictions on Test Set for each Tree
head(pred)

#mean squared test error
err = mean((housing_test$median_house_value - pred)^2)
err

mean(RF_fit$mse)
```





Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
